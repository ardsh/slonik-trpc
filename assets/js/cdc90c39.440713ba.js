"use strict";(self.webpackChunkslonik_trpc_docs=self.webpackChunkslonik_trpc_docs||[]).push([[134],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>y});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,y=d["".concat(s,".").concat(u)]||d[u]||m[u]||l;return n?a.createElement(y,r(r({ref:t},p),{},{components:n})):a.createElement(y,r({ref:t},p))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,r=new Array(l);r[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:o,r[1]=i;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},417:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const l={sidebar_position:7},r="Declaring table columns dependencies type-safely",i={unversionedId:"client-type-safety/table-selection",id:"client-type-safety/table-selection",title:"Declaring table columns dependencies type-safely",description:"A common issue when using tRPC over GraphQL is the fact that overfetching is supposed to be solved by GraphQL, but it's not clear how you can do the same thing with tRPC.",source:"@site/docs/client-type-safety/table-selection.md",sourceDirName:"client-type-safety",slug:"/client-type-safety/table-selection",permalink:"/slonik-trpc/docs/client-type-safety/table-selection",draft:!1,editUrl:"https://github.com/ardsh/slonik-trpc/tree/main/docs/docs/client-type-safety/table-selection.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Client-side patterns",permalink:"/slonik-trpc/docs/category/client-side-patterns"},next:{title:"Cursor Pagination",permalink:"/slonik-trpc/docs/client-type-safety/cursor-pagination"}},s={},c=[{value:"Setup",id:"setup",level:2},{value:"Solution",id:"solution",level:2},{value:"Example implementation",id:"example-implementation",level:2},{value:"The useColumns implementation",id:"the-usecolumns-implementation",level:3},{value:"The complete tableDataLoader implementation",id:"the-complete-tabledataloader-implementation",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"declaring-table-columns-dependencies-type-safely"},"Declaring table columns dependencies type-safely"),(0,o.kt)("p",null,"A common issue when using tRPC over GraphQL is the fact that overfetching is supposed to be solved by GraphQL, but it's not clear how you can do the same thing with tRPC."),(0,o.kt)("p",null,"I'm gonna try to show a pattern of how to create react tables with optional columns, when not all columns are supposed to be visible to the user."),(0,o.kt)("p",null,"In that case, we want to fetch only the data for the columns that we display, and not fetch all the data a tRPC query has to offer."),(0,o.kt)("h2",{id:"setup"},"Setup"),(0,o.kt)("p",null,"I'll use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/table-library/react-table-library"},"React Table Library")," for the UI, but this pattern can work with most other tables or datagrids in a very similar way."),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("p",null,"We can implement selective fetching in our tRPC APIs, using a ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," array that we pass as an argument."),(0,o.kt)("p",null,"We're gonna abstract this handling of dependencies (and pagination) in its own generic function like below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tableDataLoader.ts"',title:'"tableDataLoader.ts"'},"export const createTableLoader = <TPayload extends Record<string, any>>() => {\n  // define initial state, context providers, and reducer\n  // ...\n  return {\n    ContextProvider,\n    useVariables,\n    createColumn,\n    useColumns\n  }\n}\n")),(0,o.kt)("p",null,"This function takes a generic parameter for the type of data we're trying to load, e.g. an ",(0,o.kt)("inlineCode",{parentName:"p"},"Employee"),"  type, and will be responsible for storing the dependencies of all visible columns, as well as making the column declaration type-safe, and any other table-related data fetching responsibilities."),(0,o.kt)("h2",{id:"example-implementation"},"Example implementation"),(0,o.kt)("p",null,"Let's say you're building a table that displays employee information, using this type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="EmployeeList.ts"',title:'"EmployeeList.ts"'},"type Employee = {\n  id: number;\n  firstName: string;\n  lastName: string;\n  email: string;\n  jobTitle: string;\n  company: {\n    name: string;\n  };\n}\n")),(0,o.kt)("p",null,"Then you'd declare the columns like below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="EmployeeList.ts"',title:'"EmployeeList.ts"'},'const employeeColumns = employeeLoader.useColumns([{\n  label: \'Name\',\n  dependencies: ["firstName", "lastName"],\n  renderCell: (employee) => {\n    return <div>{employee.firstName} {employee.lastName}</div>\n  },\n}, {\n  label: \'Email\',\n  dependencies: ["email"],\n  renderCell: (employee) => employee.email,\n}, {\n  label: \'Title\',\n  dependencies: ["jobTitle"],\n  renderCell: (employee) => employee.jobTitle,\n}, {\n  label: \'Company\',\n  dependencies: ["company"],\n  renderCell: (employee) => employee.company.name,\n}]);\n')),(0,o.kt)("p",null,"This is enough for our implementation to work, however, if we want to make each renderCell function get an argument with the correct type, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"createColumn")," function to wrap each column, and make it type-safe."),(0,o.kt)("p",null,"Let's start by declaring the ",(0,o.kt)("inlineCode",{parentName:"p"},"createColumn")," function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tableDataLoader.ts"',title:'"tableDataLoader.ts"'},'import type { Column } from \'@table-library/react-table-library/types/compact\';\n\ntype ColumnDefinitions<TPayload> = Omit<Column, "renderCell" | "dependencies"> & {\n  renderCell: (item: TPayload) => React.ReactNode,\n  dependencies?: readonly (Extract<keyof TPayload, string>)[],\n};\n\nexport const createTableLoader = <TPayload extends Record<string, any>>() => {\n  // ...\n  return {\n    createColumn: <TDependencies extends keyof TPayload=never>(column: Omit<ColumnDefinitions<TPayload>, "dependencies" | "renderCell"> & {\n      dependencies?: TDependencies[],\n      renderCell: (data: Pick<TPayload, TDependencies>) =>  React.ReactNode,\n    }) => {\n      return column;\n    },\n  // ...\n  }\n}\n')),(0,o.kt)("p",null,"Whoa, that looks like some complex typescript! What we're essentially doing here though, is restricting the data type, using the ",(0,o.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys"},(0,o.kt)("inlineCode",{parentName:"a"},"Pick"))," utility."),(0,o.kt)("p",null,"So if you specify only the ",(0,o.kt)("inlineCode",{parentName:"p"},"firstName")," field in a column, you won't be able to access other fields in the ",(0,o.kt)("inlineCode",{parentName:"p"},"renderCell "),"function. E.g. accessing ",(0,o.kt)("inlineCode",{parentName:"p"},"employee.email")," would result in a typescript error."),(0,o.kt)("p",null,"Now simply wrap all your columns in this helper function. The best part about this is, you get type-safety AND composability, by declaring the columns in different places, then simply adding them to the array you need."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'export const nameColumn = employeeLoader.createColumn({\n  label: \'Name\',\n  dependencies: ["firstName", "lastName"],\n  renderCell: (employee) => {\n    return <div>{employee.firstName} {employee.lastName}</div>\n  },\n});\n\nexport const companyColumn = employeeLoader.createColumn({\n  label: \'Company\',\n  dependencies: ["company"],\n  renderCell: (employee) => employee.company.name,\n});\n// ...\n\nconst columns = employeeLoader.useColumns([\n  nameColumn,\n  employeeColumn,\n]);\n')),(0,o.kt)("h3",{id:"the-usecolumns-implementation"},"The useColumns implementation"),(0,o.kt)("p",null,"Now we need to actually implement the useColumns function, and the rest of the table data loader."),(0,o.kt)("p",null,"We start by saving the dependencies array in a reducer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tableDataLoader.ts"',title:'"tableDataLoader.ts"'},"import React from 'react';\n\ntype Action = {\n  type: \"APPEND_FIELDS\",\n  dependencies: string[]\n};\n\ntype State = {\n  dependencies: string[]\n}\n\nconst stateReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case 'APPEND_FIELDS':\n      return {\n        ...state,\n        // Sort alphabetically to have a stable array\n        dependencies: [... new Set(state.dependencies.concat(action.dependencies))].sort(),\n      };\n    default: return state;\n  }\n}\n")),(0,o.kt)("p",null,"This is a simple array of unique strings, that are sorted alphabetically (to prevent tRPC refetching queries if the dependent fields are the same but in a different order)."),(0,o.kt)("p",null,"We're gonna pass this dependencies array down using a context provider."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tableDataLoader.ts"',title:'"tableDataLoader.ts"'},'export const createTableLoader = <TPayload extends Record<string, any>>() => {\n  const initialState = {\n    dependencies: [],\n  };\n  const DependenciesContext = React.createContext([] as (keyof TPayload)[]);\n  const DispatchContext = React.createContext((() => {\n    throw new Error("tableDataLoader Context provider not found!");\n  }) as React.Dispatch<Action>);\n\n  return {\n    ContextProvider: ({ children }: { children: React.ReactNode }) => {\n      const [state, dispatch] = React.useReducer(stateReducer, initialState);\n      return (<DispatchContext.Provider value={dispatch}>\n        <DependenciesContext.Provider value={state.dependencies}>\n          {children}\n        </DependenciesContext.Provider>\n      </DispatchContext.Provider>)\n    },\n    // ...\n}\n')),(0,o.kt)("p",null,"The context provider makes it possible to access the state in sub-components.\nYou simply need to provide it at the root of your page, before you use any loader hooks."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="EmployeeList.tsx"',title:'"EmployeeList.tsx"'},"<employeeLoader.ContextProvider>\n  <EmployeesTable />\n</employeeLoader.ContextProvider>\n")),(0,o.kt)("p",null,"Finally, we implement the useColumns and useVariables functions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tableDataLoader.ts"',title:'"tableDataLoader.ts"'},"import type { Column } from  '@table-library/react-table-library/types/compact';\n\nconst diff = (arr1: any[], arr2: any[]) => {\n  return arr1.filter(x => !arr2.includes(x));\n}\n\ntype ColumnDefinitions<TPayload> = Omit<Column, \"renderCell\"> & {\n  renderCell: (item: TPayload) => React.ReactNode,\n  dependencies?: readonly (Extract<keyof TPayload, string>)[],\n};\n\nexport const createTableLoader = <TPayload  extends  Record<string, any>>() => {\n  // ... context state\n  return {\n    ContextProvider: //...\n    useColumns: (columns: ColumnDefinitions<TPayload>[]) => {\n      const dispatch = React.useContext(DispatchContext);\n      const existingDeps = React.useContext(DependenciesContext);\n      React.useEffect(() => {\n        const select = columns.flatMap(column => {\n          return (column.dependencies || [])\n        }).filter(Boolean);\n        if (diff(dependencies, existingDeps).length) {\n          // We only add fields to dependencies array, without removing.\n          dispatch({\n            type: 'APPEND_FIELDS',\n            dependencies: dependencies,\n          });\n        }\n      }, [existingDeps, columns]);\n      return columns;\n    },\n    useVariables: () => {\n      const dependencies = React.useContext(DependenciesContext);\n      return React.useMemo(() => ({\n        select: dependencies,\n      }), [dependencies]);\n    },\n  }\n}\n")),(0,o.kt)("p",null,"We're gonna use the ",(0,o.kt)("inlineCode",{parentName:"p"},"useVariables")," hook to get the select array while fetching the data with trpc, and pass it as an argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="EmployeeList.tsx"',title:'"EmployeeList.tsx"'},"const employeeLoader = createTableLoader<Employee>();\n\n// ...\n\nconst { select } = employeeLoader.useVariables();\nconst { data, isLoading } = trpc.employees.getEmployees.useQuery({\n  select,\n});\n// ...\nreturn <Table data={data.nodes} />\n")),(0,o.kt)("p",null,"So the API will now return just the fields that we actually need to display our columns."),(0,o.kt)("h2",{id:"the-complete-tabledataloader-implementation"},"The complete tableDataLoader implementation"),(0,o.kt)("p",null,"Finally, here's the complete implementation of the table data loader function so far:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import type { Column } from \'@table-library/react-table-library/types/compact\';\nimport React from \'react\';\n\nconst diff = (arr1: any[], arr2: any[]) => {\n  return arr1.filter(x => !arr2.includes(x));\n}\n\ntype Action = {\n  type: "APPEND_FIELDS",\n  dependencies: string[]\n};\n\ntype ColumnDefinitions<TPayload> = Omit<Column, "renderCell" | "dependencies"> & {\n  renderCell: (item: TPayload) => React.ReactNode,\n  dependencies?: readonly (Extract<keyof TPayload, string>)[],\n};\n\ntype State = {\n  dependencies: string[]\n}\n\nconst stateReducer = (state: State, action: Action) => {\n  switch (action.type) {\n    case \'APPEND_FIELDS\':\n      return {\n        ...state,\n        // Sort alphabetically to have a stable array\n        dependencies: [... new Set(state.dependencies.concat(action.dependencies))].sort(),\n      };\n    default: return state;\n  }\n}\n\nexport const  createTableLoader = <TPayload  extends  Record<string, any>>() => {\n  const initialState = {\n    dependencies: [],\n  };\n  const DependenciesContext = React.createContext([] as (keyof TPayload)[]);\n  const DispatchContext = React.createContext((() => {\n    throw new Error("tableDataLoader Context provider not found!");\n  }) as React.Dispatch<Action>);\n\n  return {\n    ContextProvider: ({ children }: { children: React.ReactNode }) => {\n      const [state, dispatch] = React.useReducer(stateReducer, initialState);\n      return (<DispatchContext.Provider value={dispatch}>\n        <DependenciesContext.Provider value={state.dependencies}>\n          {children}\n        </DependenciesContext.Provider>\n      </DispatchContext.Provider>)\n    },\n    useColumns: (columns: ColumnDefinitions<TPayload>[]) => {\n      const dispatch = React.useContext(DispatchContext);\n      const existingDeps = React.useContext(DependenciesContext);\n      React.useEffect(() => {\n        const dependencies = columns.flatMap(column => {\n          return (column.dependencies || [])\n        }).filter(Boolean);\n        if (diff(dependencies, existingDeps).length) {\n          // We only add fields to dependencies array, without removing.\n          dispatch({\n            type: \'APPEND_FIELDS\',\n            dependencies: dependencies,\n          });\n        }\n      }, [existingDeps, columns]);\n      return columns;\n    },\n    useVariables: () => {\n      const dependencies = React.useContext(DependenciesContext);\n      return React.useMemo(() => ({\n        select: dependencies,\n      }), [dependencies]);\n    },\n    createColumn: <TDependencies extends keyof  TPayload=never>(column: Omit<ColumnDefinitions<TPayload>, "dependencies" | "renderCell"> & {\n      dependencies?: TDependencies[],\n      renderCell: (data: Pick<TPayload, TDependencies>) =>  React.ReactNode,\n    }) => {\n      return column;\n    },\n  }\n}\n')),(0,o.kt)("p",null,"And the table component"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import React from 'react';\nimport { CompactTable } from '@table-library/react-table-library/compact';\n\nimport { trpc, type Employee } from '../../utils/trpc';\n\nconst employeeTableLoader = createTableLoader<Employee>();\n\nexport default function EmployeeList() {\n  const employeeColumns = employeeTableLoader.useColumns([\n    employeeTableLoader.createColumn({\n        label: 'Name',\n        dependencies: [\"firstName\", \"lastName\"],\n        renderCell: (employee) => {\n            return <div>{employee.firstName} {employee.lastName}</div>\n        },\n    }), employeeTableLoader.createColumn({\n        label: 'Salary',\n        dependencies: [\"salary\"],\n        renderCell: (employee) => employee.salary,\n    }), employeeTableLoader.createColumn({\n        label: 'Start Date',\n        dependencies: [\"startDate\"],\n        renderCell: (employee) => employee.startDate,\n    }), employeeTableLoader.createColumn({\n        label: 'Company',\n        dependencies: [\"company\"],\n        renderCell: (employee) => employee.company,\n    })\n  ]);\n\n  const pagination = employeeTableLoader.useVariables();\n\n  const { data, isLoading } = trpc.employees.getPaginated.useQuery({\n    take: 100,\n    ...pagination,\n  });\n\n  if (!data) return null;\n\n  return (\n    <>\n      <CompactTable columns={employeeColumns} data={data} />\n    </>\n  );\n}\n")))}d.isMDXComponent=!0}}]);